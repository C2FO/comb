<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>comb</title>
    <link rel="stylesheet" href="./assets/css/bootstrap.css">
    <link rel="stylesheet" href="./assets/css/prettify.css">
    <style type="text/css">
        

/*.subnav-inner {*/
    /*width: 100%;*/
    /*height: 36px;*/
    /*background-color: #EEE;*/
    /*background-repeat: repeat-x;*/
    /*background-image: -moz-linear-gradient(top, whiteSmoke 0%, #EEE 100%);*/
    /*background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, whiteSmoke), color-stop(100%, #EEE));*/
    /*background-image: -webkit-linear-gradient(top, whiteSmoke 0%, #EEE 100%);*/
    /*background-image: -ms-linear-gradient(top, whiteSmoke 0%, #EEE 100%);*/
    /*background-image: -o-linear-gradient(top, whiteSmoke 0%, #EEE 100%);*/
    /*filter: progid:DXImageTransform.Microsoft.gradient(startColorstr = '#f5f5f5', endColorstr = '#eeeeee', GradientType = 0);*/
    /*background-image: linear-gradient(top, whiteSmoke 0%, #EEE 100%);*/
    /*-webkit-border-radius: 4px;*/
    /*-moz-border-radius: 4px;*/
    /*border-radius: 4px;*/
/*}*/

/*.subnav .nav > li > a:hover {*/
    /*color: black !important;*/
/*}*/

/*.subnav .nav li.dropdown .dropdown-toggle .caret,*/
/*.subnav .nav li.dropdown.open .caret {*/
    /*border-top-color: #999 !important;*/
    /*border-bottom-color: #999 !important;*/
/*}*/

/*.subnav-fixed {*/
    /*position: fixed;*/
    /*width : 90%;*/
    /*margin-right: auto;*/
    /*margin-left: auto;*/
    /*top: 40px;*/
    /*left: 0;*/
    /*right: 0;*/
    /*z-index: 1020;*/
    /*border-color: #D5D5D5;*/
    /*border-width: 0 0 1px;*/
    /*-webkit-border-radius: 0;*/
    /*-moz-border-radius: 0;*/
    /*border-radius: 0;*/
    /*-webkit-box-shadow: inset 0 1px 0 #fff, 0 1px 5px rgba(0,0,0,.1);*/
    /*-moz-box-shadow: inset 0 1px 0 #fff, 0 1px 5px rgba(0,0,0,.1);*/
    /*box-shadow: inset 0 1px 0 #fff, 0 1px 5px rgba(0,0,0,.1);*/
    /*filter: progid:DXImageTransform.Microsoft.gradient(enabled=false);*/
/*}*/

/*.navbar .nav  .dropdown-menu {*/
    /*max-height: 500px;*/
    /*overflow: auto;*/
/*}â€‹*/

    </style>
    <style type="text/css">
        body {
            padding: 90px;
        }

        .subnav{
            margin-top: 40px;
            margin-right: auto;
            margin-left: auto;
            z-index: 1000;
        }

        @media (max-width:979px) {
            .subnav{
                margin-top: auto;
            }
        }
    </style>
    <link rel="stylesheet" href="./assets/css/bootstrap-responsive.css">
    <script type="text/javascript">
        var init = (function () {
            "use strict";

            var processScroll = (function () {
                var curr = null, prev = null;
                return function (nav) {
                    var $win = $(window);
                    $('.subnav').each(function () {
                        var nav = $(this);
                        var navTop = $win.width() < 980 ? 0 : nav.offset().top - 40;

                        var scrollTop = $win.scrollTop();
                        if (scrollTop >= navTop && curr != nav) {
                            if(curr){
                                curr.removeClass('subnav-fixed')
                                prev = curr;
                            }
                            curr = nav;
                            curr.addClass('subnav-fixed')
                        } else if (curr == nav && scrollTop <= navTop) {
                            curr.removeClass('subnav-fixed');
                            prev.addClass('subnav-fixed');
                            curr = prev;
                        }else{
                            nav.removeClass('subnav-fixed');
                        }
                    });
                };
            })();

            return function () {
                window.prettyPrint && prettyPrint();
                $(".collapse").collapse();
                var $window = $(window);
                //$(".subnav").affix ();
                // fix sub nav on scroll
//                processScroll();
//                $(window).on('scroll', processScroll)
            }
        })();
    </script>
</head>
<body onload="init()">
<div class="navbar navbar-fixed-top navbar-inverse">
    <div class="navbar-inner">
        <div class="container">
            <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"> </span>
            </a>
            
            <a href="./index.html" class="brand">comb</a>
            
            <div class="nav-collapse">
                <ul class="nav">
                    
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Docs<b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
                            <li><a href="./define.html">OO</a></li>
                            
                            <li><a href="./promise.html">Promises</a></li>
                            
                            <li><a href="./logging.html">Logging</a></li>
                            
                            <li><a href="./utilities.html">Utilities</a></li>
                            
                            <li><a href="./coverage.html">Test Coverage</a></li>
                            
                        </ul>
                        

                        
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Namespaces<b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
                            <li><a href="comb.html">comb</a></li>
                            
                            <li><a href="comb_array.html">comb.array</a></li>
                            
                            <li><a href="comb_characters.html">comb.characters</a></li>
                            
                            <li><a href="comb_date.html">comb.date</a></li>
                            
                            <li><a href="comb_logger.html">comb.logger</a></li>
                            
                            <li><a href="comb_number.html">comb.number</a></li>
                            
                            <li><a href="comb_plugins.html">comb.plugins</a></li>
                            
                            <li><a href="comb_regexp.html">comb.regexp</a></li>
                            
                            <li><a href="comb_string.html">comb.string</a></li>
                            
                        </ul>
                    </li>
                    
                    
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
                            <li><a href="./comb_Promise.html">comb.Promise</a></li>
                            
                            <li><a href="./comb_PromiseList.html">comb.PromiseList</a></li>
                            
                            <li><a href="./comb_collections_AVLTree.html">comb.collections.AVLTree</a></li>
                            
                            <li><a href="./comb_collections_AnderssonTree.html">comb.collections.AnderssonTree</a></li>
                            
                            <li><a href="./comb_collections_BinaryTree.html">comb.collections.BinaryTree</a></li>
                            
                            <li><a href="./comb_collections_Collection.html">comb.collections.Collection</a></li>
                            
                            <li><a href="./comb_collections_HashTable.html">comb.collections.HashTable</a></li>
                            
                            <li><a href="./comb_collections_Heap.html">comb.collections.Heap</a></li>
                            
                            <li><a href="./comb_collections_Iterable.html">comb.collections.Iterable</a></li>
                            
                            <li><a href="./comb_collections_MaxHeap.html">comb.collections.MaxHeap</a></li>
                            
                            <li><a href="./comb_collections_MinHeap.html">comb.collections.MinHeap</a></li>
                            
                            <li><a href="./comb_collections_Pool.html">comb.collections.Pool</a></li>
                            
                            <li><a href="./comb_collections_PriorityQueue.html">comb.collections.PriorityQueue</a></li>
                            
                            <li><a href="./comb_collections_Queue.html">comb.collections.Queue</a></li>
                            
                            <li><a href="./comb_collections_RedBlackTree.html">comb.collections.RedBlackTree</a></li>
                            
                            <li><a href="./comb_collections_Stack.html">comb.collections.Stack</a></li>
                            
                            <li><a href="./comb_collections_Tree.html">comb.collections.Tree</a></li>
                            
                            <li><a href="./comb_logging_BasicConfigurator.html">comb.logging.BasicConfigurator</a></li>
                            
                            <li><a href="./comb_logging_Level.html">comb.logging.Level</a></li>
                            
                            <li><a href="./comb_logging_Logger.html">comb.logging.Logger</a></li>
                            
                            <li><a href="./comb_logging_PropertyConfigurator.html">comb.logging.PropertyConfigurator</a></li>
                            
                            <li><a href="./comb_logging_appenders_Appender.html">comb.logging.appenders.Appender</a></li>
                            
                            <li><a href="./comb_logging_appenders_ConsoleAppender.html">comb.logging.appenders.ConsoleAppender</a></li>
                            
                            <li><a href="./comb_logging_appenders_FileAppender.html">comb.logging.appenders.FileAppender</a></li>
                            
                            <li><a href="./comb_logging_appenders_JSONAppender.html">comb.logging.appenders.JSONAppender</a></li>
                            
                            <li><a href="./comb_logging_appenders_RollingFileAppender.html">comb.logging.appenders.RollingFileAppender</a></li>
                            
                            <li><a href="./comb_plugins_Broadcaster.html">comb.plugins.Broadcaster</a></li>
                            
                            <li><a href="./comb_plugins_Middleware.html">comb.plugins.Middleware</a></li>
                            
                        </ul>
                    </li>
                    
                </ul>
                
                <ul class="nav pull-right">

                    <li class="divider-vertical"></li>
                    <li><a href="https://github.com/Pollenware/comb" target="#github" class="pull-right">github</a></li>
                </ul>
                
            </div>
        </div>
    </div>
</div>



<div class="container-fluid">
    <a name="top"></a>
    <div class="container">



<h1><a href="./comb_Promise.html">Promises</a></h1>
<p><code>comb</code> provides an async wrapper called a <a href="http://en.wikipedia.org/wiki/Futures_and_promises">promise</a>. Promises are a way of handling async and sync behavior by encapsulating it in a wrapper. One of the benefits of promises is that it encourages the separation of success and failure logic, and provides a value that can be passed around rather than providing callbacks for every async action. 

</p>
<h2><a href="./comb_Promise.html">comb.Promise</a></h2>
<p>The <a href="./comb_Promise.html">comb.Promise</a> is the backbone for <code>comb</code>s async utilities. 

</p>
<p>To create a promise

</p>
<pre class='prettyprint linenums lang-js'><code>var promise = new comb.Promise();</code></pre>
<h3>Resolving Promises</h3>
<p>When working with a promise you must resolve the promise in order to callbacks/errbacks to be invoked. Resolution can happen before for after callbacks/errbacks have been registered. The methods to resolve a promise are <code>callback</code>, <code>errback</code>, and <code>resolve</code>.

</p>
<h3>callback  and errback</h3>
<p>The callback method is used to resolve a promise as a success.

</p>
<pre class='prettyprint linenums lang-js'><code>
function readFile(file, encoding){
    var ret = new comb.Promise();
    fs.readFile(file, encoding || &quot;utf8&quot;, function(err){
        if(err){
            //there was an error so errback
            ret.errback(err);
        }else{
            //resolve the promise removing the first argument
            ret.callback(comb.argsToArray(arguments, 1));
        }
    });
    //return the promise object which removes the &#39;callback&#39;, &#39;errback&#39; and &#39;resolve&#39; functions.
    return ret.promise();
}

readFile(&quot;myFile.txt&quot;).then(function(text){
    console.log(text);
}, errorHandler);</code></pre>
<p>As you can see from above we can easily wrap the <code>fs.readFile</code> function with a promise. The advantage of this is that you can now seperate the success and error resolution paths with the <code>then</code> function. The above example just passes the error to a global error handler and your success callback does not have to worry about the error condition.

</p>
<h3>resolve</h3>
<p><code>callback</code> and <code>errback</code> are great if you are working with other promise methods but as you can see from above you still have to handle the error and success path when working with node style callback. This is where the <code>resolve</code> method comes in handy.

</p>
<p>Resolve wraps <code>callback</code> and <code>errback</code> in a single method that accepts an <code>error</code> as the first argument. If the error is undefined or null then the rest of the arguments are used to resolve the promise.

</p>
<p>Lets rewrite the <code>readFile</code> funciton with resolve.

</p>
<pre class='prettyprint linenums lang-js'><code>
function readFile(file, encoding){
    var ret = new comb.Promise();
    fs.readFile(file, encoding || &quot;utf8&quot;, ret.resolve.bind(ret));
    //return the promise object which removes the &#39;callback&#39;, &#39;errback&#39; and &#39;resolve&#39; functions.
    return ret.promise();
}

readFile(&quot;myFile.txt&quot;).then(function(text){
    console.log(text);
}, errorHandler);</code></pre>
<p>After rewriting the <code>readFile()</code> method with resolve the code is a lot cleaner with only three lines and you still get the same promise API.


</p>
<h3>Listening for Promise Resolutions.</h3>
<p>To listen for the resolution of promises there are the following methods. For the following examples we will use the <code>readFile</code> method defined above.

</p>
<h3>then</h3>
<p>The <code>then</code> methods accepts two arugments a <code>callback</code> and an optional <code>errback</code>.

</p>
<pre class='prettyprint linenums lang-js'><code>var readFilePromise = readFile(&quot;myFile.txt&quot;);

//with two callbacks
readFilePromise.then(
    function(file){
        console.log(&quot;file&quot;)
    }, 
    function(err){
        console.log(err);
    }
);

//reusing the same promise Ignoring the error case
readFilePromise.then(function(file){
    console.log(file);
});</code></pre>
<p>You may also pass in a new promise into the <code>then</code> method.

</p>
<pre class='prettyprint linenums lang-js'><code>
var readAndConvertToUppercase = function(file, encoding){
    var ret = new comb.Promise();
    readFile(&quot;myFile.txt&quot;).then(
        function(data){
            ret.callback(data.toUpperCase());
        }, 
        //pass in the return promise as the second argument. 
        //this is the same as setting the errback to ret.errback.bind(ret);
        ret
    );
    return ret.promise();
};

//with two callbacks
readAndConvertToUppercase(&quot;myFile.txt&quot;).then(
    function(file){
        console.log(&quot;file&quot;)
    }, 
    function(err){
        console.log(err);
    }
);</code></pre>
<h3>classic</h3>
<p>The <code>classic</code> method can be used to register a callback with a node style callback

</p>
<pre class='prettyprint linenums lang-js'><code>
readFile(&quot;myFile.txt&quot;).classic(function(err, file){
    if(err){
        console.log(err);
    }else{
        console.log(file);
    }
});</code></pre>
<h3>chain</h3>
<p>The chain method is used to chain promises together so they execute ir order. The chain method is different from the <a href="./comb.html#.serial">comb.serial</a> method in that it pipes the results from one promise into the next.

</p>
<p>In the following example we chain the results of different promise actions into a single result.

</p>
<pre class='prettyprint linenums lang-js'><code>function asyncString(str){
    var ret = new comb.Promise();
    process.nextTick(ret.callback.bind(ret, str));
    return ret.promise();
}

asyncString(&quot;hello&quot;)
    .chain(function(results){
        return asyncString(results + &quot; world&quot;);
    })
    .chain(function(results){
        return asyncString(results + &quot;!&quot;);
    })
    .then(function(str){
        console.log(str); //&quot;hello world!&quot;
    });</code></pre>
<h2><a href="./comb_PromiseList.html">comb.PromiseList</a></h2>
<p>A promise list is used to listen for the completion of an array of promises. 

</p>
<pre class='prettyprint linenums lang-js'><code>var files = [readFile(&quot;myFile.txt&quot;),readFile(&quot;myFile2.txt&quot;),readFile(&quot;myFile3.txt&quot;)];

function readFiles(){
    var files = comb.argsToArray(arguments).map(function(file){
        return readFile(file);
    });
    return new comb.PromiseList(files, true).promise();

}

readFiles(&quot;myFile.txt&quot;, &quot;myFile2.txt&quot;, &quot;myFile3.txt&quot;).then(function(files){
    files.forEach(function(data){
        console.log(data);
    });
}, errorHandler);</code></pre>
<h2><a href="./comb.html#.when">comb.when</a></h2>
<p>The <code>comb.when</code> function allows one to wrap a sync or async call or calls with the same API.

</p>
<p>In the following example we created a new function that reads the files synchronoulsly. We then use the <code>comb.when</code> function to wrap both the async and sync calls in a promise.

</p>
<pre class='prettyprint linenums lang-js'><code>function readFileSync(){
    return fs.readFileSync.apply(fs, arguments);
}

comb.when(
    readFile(&quot;myFile.txt&quot;),
    readFileSync(&quot;myFile.txt&quot;),
    readFile(&quot;myFile1.txt&quot;),
    readFileSync(&quot;myFile1.txt&quot;),
    readFile(&quot;myFile2.txt&quot;),
    readFileSync(&quot;myFile2.txt&quot;),
).then(function(files){
    files.forEach(function(data){
        console.log(data);
    });
}, errorHandler);</code></pre>
<h2><a href="./comb.html#.serial">comb.serial</a></h2>
<p>The <code>comb.serial</code> function is useful if you need to perform a set of actions in order. The serial method takes a list of function that need to be executed in order. The return value of the functions can be anything if they are promises then the next function will not execute until the promise has resolved. The results from each function are will be the result of the returned promise. <strong>NOTE</strong> the results from each function are not propogated to the next.


</p>
<pre class='prettyprint linenums lang-js'><code>var asyncAction = function(item, timeout){                                
   var ret = new comb.Promise(); 
   //bind the callback to the promise ignoring any other arguments passed in                                      
   setTimeout(ret.callback.bind(ret, item), timeout);
   return ret.promise();                                                            
};                                                                        

comb.serial([   
    //comb.partial returns a function that will execute asyncAction with the specified arguments
    comb.partial(asyncAction, 1, 1000),                                       
    comb.partial(asyncAction, 2, 900),                                  
    comb.partial(asyncAction, 3, 800),                                    
    comb.partial(asyncAction, 4, 700),                                    
    comb.partial(asyncAction, 5, 600),                                    
    comb.partial(asyncAction, 6, 500)                                     
]).then(function(results){                                                
    console.log(results); // [1,2,3,4,5,6];                               
});</code></pre>
<h2><a href="./comb.html#.chain">comb.chain</a></h2>
<p>The <code>comb.chain</code> method is similar to the <code>comb.serial</code> method except that it <strong>does</strong> propogate results from one function to the next. The promise returned from <code>comb.chain</code> will resolve with the result of the last action in the list.

</p>
<pre class='prettyprint linenums lang-js'><code>function asyncAction(add, timeout) {   
    //number gathered from the previous function
     return function (num) {           
         //will be undefined if the first function in the list.
         num = num || 0;               
         var ret = new comb.Promise(); 
         setTimeout(function () {      
              ret.callback(num + add); 
         }, timeout);                  
         return ret;                   
     }                                 
}                                      

comb.chain([                           
     asyncAction(1, 100),              
     asyncAction(2, 100),              
     asyncAction(3, 100),              
     asyncAction(4, 100),              
     asyncAction(5, 100),              
]).then(function(results){             
     console.log(results); //15        
});</code></pre>
<h2><a href="./comb.html#.wrap">comb.wrap</a></h2>
<p>The <code>comb.wrap</code> method is used to wrap a function that is defined with a node style callback in a promise.

</p>
<p>Suppose we wanted to wrap all async fs methods in a promise we could do the following.

</p>
<pre class='prettyprint linenums lang-js'><code>var fsFunctions = [&quot;rename&quot;,&quot;truncate&quot;,&quot;chown&quot;,&quot;fchown&quot;, &quot;lchown&quot;,&quot;chmod&quot;,&quot;fchmod&quot;,&quot;lchmod&quot;, &quot;stat&quot;,
    &quot;lstat&quot;,&quot;fstat&quot;, &quot;link&quot;,&quot;symlink&quot;, &quot;readlink&quot;,&quot;realpath&quot;,&quot;unlink&quot;, &quot;rmdir&quot;,&quot;mkdir&quot;,
    &quot;readdir&quot;,&quot;close&quot;, &quot;open&quot;,&quot;utimes&quot;, &quot;futimes&quot;,&quot;fsync&quot;, &quot;write&quot;,&quot;read&quot;, &quot;readFile&quot;,
    &quot;writeFile&quot;,&quot;appendFile&quot;];

var fsp = {};

fsFunctions.forEach(function(method){
    fsp[method] = comb.wrap(fs[method], fs);
});</code></pre>
<p>We could then use each <code>fsp</code> method as promise returning function.

</p>
<pre class='prettyprint linenums lang-js'><code>fsp.rename(&quot;myFile.txt&quot;, &quot;myFile.txt.bak&quot;).then(function(){
    //do something.
});</code></pre>

<hr>

    
  <h2>License</h2>
<p>MIT <a href="https://github.com/Pollenware/comb/raw/master/LICENSE">https://github.com/Pollenware/comb/raw/master/LICENSE</a>

</p>
<h2>Meta</h2>
<ul>
<li>Code: <code>git clone git://github.com/Pollenware/comb.git</code></li>
<li>Website: <a href="http://pollenware.com">http://pollenware.com</a></li>
<li>Twitter: <a href="http://twitter.com/pollenware"><a href="http://twitter.com/pollenware">http://twitter.com/pollenware</a></a> - 877.465.4045</li>
</ul>




</div>
</div>
<script type="text/javascript" src="./assets/js/jquery.js"></script>
<script type="text/javascript" src="./assets/js/bootstrap.min.js"></script>
<script type="text/javascript" src="./assets/js/prettify.js"></script>

</body>
</html>
